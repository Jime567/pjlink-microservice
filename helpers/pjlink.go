package helpers

import (
	"errors"
	"fmt"
	"strconv"
)

var HumanToRawCommands = map[string]string{
	"power":        "POWR",
	"input-list":   "INST",
	"input":        "INPT",
	"av-mute":      "AVMT",
	"error-status": "ERST",
	"lamp":         "LAMP",
	"name":         "NAME",
	"manufacturer": "INF1",
	"model":        "INF2",
	"version":      "INFO",
}

var RawToHumanCommands = map[string]string{
	"POWR": "power",
	"INST": "input-list",
	"INPT": "input",
	"AVMT": "av-mute",
	"ERST": "error-status",
	"LAMP": "lamp",
	"NAME": "name",
	"INF1": "manufacturer",
	"INF2": "model",
	"INFO": "version",
}

var PowerRequests = map[string]string{
	"query":     "?",
	"power-on":  "1",
	"power-off": "0",
}

var PowerQueryResponses = map[string]string{
	"0":    "power-off (standby)",
	"1":    "power-on (lamp on)",
	"2":    "cooling",
	"3":    "warm-up",
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var PowerResponses = map[string]string{
	"OK":   "success, or already current state",
	"ERR2": "out of parameter",
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var InputListRequests = map[string]string{
	"query": "?",
}

var InputListQueryResponses = map[string]string{
	// "inputs" to be generated by interpretInputListInputs() function
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var InputRequests = map[string]string{

	"query":     "?",
	"rgb 1":     "11",
	"rgb 2":     "12",
	"rgb 3":     "13",
	"rgb 4":     "14",
	"rgb 5":     "15",
	"rgb 6":     "16",
	"rgb 7":     "17",
	"rgb 8":     "18",
	"rgb 9":     "19",
	"video 1":   "21",
	"video 2":   "22",
	"video 3":   "23",
	"video 4":   "24",
	"video 5":   "25",
	"video 6":   "26",
	"video 7":   "27",
	"video 8":   "28",
	"video 9":   "29",
	"digital 1": "31",
	"digital 2": "32",
	"digital 3": "33",
	"digital 4": "34",
	"digital 5": "35",
	"digital 6": "36",
	"digital 7": "37",
	"digital 8": "38",
	"digital 9": "39",
	"storage 1": "41",
	"storage 2": "42",
	"storage 3": "43",
	"storage 4": "44",
	"storage 5": "45",
	"storage 6": "46",
	"storage 7": "47",
	"storage 8": "48",
	"storage 9": "49",
	"network 1": "51",
	"network 2": "52",
	"network 3": "53",
	"network 4": "54",
	"network 5": "55",
	"network 6": "56",
	"network 7": "57",
	"network 8": "58",
	"network 9": "59",
}

var InputQueryResponses = map[string]string{
	//<x><y> - handled by interpretInputQueryResponse() function
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var InputResponses = map[string]string{
	"OK":   "OK",
	"ERR2": "nonexistent input source",
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var RawToHumanInputs = map[string]string{
	"11": "rgb 1",
	"12": "rgb 2",
	"13": "rgb 3",
	"14": "rgb 4",
	"15": "rgb 5",
	"16": "rgb 6",
	"17": "rgb 7",
	"18": "rgb 8",
	"19": "rgb 9",
	"21": "video 1",
	"22": "video 2",
	"23": "video 3",
	"24": "video 4",
	"25": "video 5",
	"26": "video 6",
	"27": "video 7",
	"28": "video 8",
	"29": "video 9",
	"31": "digital 1",
	"32": "digital 2",
	"33": "digital 3",
	"34": "digital 4",
	"35": "digital 5",
	"36": "digital 6",
	"37": "digital 7",
	"38": "digital 8",
	"39": "digital 9",
	"41": "storage 1",
	"42": "storage 2",
	"43": "storage 3",
	"44": "storage 4",
	"45": "storage 5",
	"46": "storage 6",
	"47": "storage 7",
	"48": "storage 8",
	"49": "storage 9",
	"51": "network 1",
	"52": "network 2",
	"53": "network 3",
	"54": "network 4",
	"55": "network 5",
	"56": "network 6",
	"57": "network 7",
	"58": "network 8",
	"59": "network 9",
}

var AVMuteRequests = map[string]string{
	"query":          "?",
	"video-mute-on":  "11",
	"video-mute-off": "10",
	"audio-mute-on":  "21",
	"audio-mute-off": "20",
	"av-mute-on":     "31",
	"av-mute-off":    "30",
}

var AVMuteQueryResponses = map[string]string{
	"11":   "video mute on, audio mute off",
	"21":   "audio mute on, video mute off",
	"31":   "video and audio mute on",
	"30":   "video and audio mute off",
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var AVMuteResponses = map[string]string{
	"OK":   "successful execution, or state already current",
	"ERR2": "out of parameter",
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var ErrorStatusRequests = map[string]string{
	"query": "?",
}

var ErrorStatusQueryResponses = map[string]string{
	//<a><b><c>...<f> - use interpretErrorStatusResponse() function
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var LampRequests = map[string]string{
	"query": "?",
}

var LampQueryResponses = map[string]string{
	//<a> <b> - use interpretLampQueryResponse() function
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var LampStateResponses = map[string]string{
	"0": "off",
	"1": "on",
}

var NameRequests = map[string]string{
	"query": "?",
}

var NameQueryResponses = map[string]string{
	//<hostname> - just pass through
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var ManufacturerRequests = map[string]string{
	"query": "?",
}

var ManufacturerQueryResponses = map[string]string{
	//<manufacturer> - just pass through
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var ModelRequests = map[string]string{
	"query": "?",
}

var ModelQueryResponses = map[string]string{
	//<model> - just pass through
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

var VersionRequests = map[string]string{
	"query": "?",
}

var VersionQueryResponses = map[string]string{
	//<version> - just pass through
	"ERR3": "unavailable time",
	"ERR4": "device failure",
}

type PJResponse struct {
	Class    string   `json:"class"`
	Command  string   `json:"command"`
	Response []string `json:"response"`
}

//takes a PJRequest in human readable format
//success: returns a human readable PJResponse
//fail: returns an empty PJResponse, and accompanying error message
func HandleRequest(request PJRequest) (PJResponse, error) {
	//first validate request before sending
	validateError := validateHumanRequest(request)
	if validateError != nil {
		return PJResponse{}, errors.New("Not a valid request: " +
			validateError.Error())
	}

	//convert raw PJLink request
	rawResponse, handleRawRequestError := HandleRawRequest(
		convertHumanRequestToRawRequest(request))

	if handleRawRequestError != nil {
		return PJResponse{}, handleRawRequestError
	} else {
		response, error := convertRawResponseToHumanResponse(
			rawResponse, request.Parameter)
		if error != nil {
			return PJResponse{}, error
		} else {
			return response, nil
		}
	}
}

func convertHumanRequestToRawRequest(request PJRequest) PJRequest {
	rawPJRequest := PJRequest{Address: request.Address, Port: request.Port,
		Password: request.Password, Class: request.Class,
		Command: HumanToRawCommands[request.Command]}

	switch request.Command {
	case "power":
		rawPJRequest.Parameter = PowerRequests[request.Parameter]
	case "input-list":
		rawPJRequest.Parameter = InputListRequests[request.Parameter]
	case "input":
		rawPJRequest.Parameter = InputRequests[request.Parameter]
	case "av-mute":
		rawPJRequest.Parameter = AVMuteRequests[request.Parameter]
	case "error-status":
		rawPJRequest.Parameter = ErrorStatusRequests[request.Parameter]
	case "lamp":
		rawPJRequest.Parameter = LampRequests[request.Parameter]
	case "name":
		rawPJRequest.Parameter = NameRequests[request.Parameter]
	case "manufacturer":
		rawPJRequest.Parameter = ManufacturerRequests[request.Parameter]
	case "model":
		rawPJRequest.Parameter = ModelRequests[request.Parameter]
	case "version":
		rawPJRequest.Parameter = VersionRequests[request.Parameter]
	}
	fmt.Println(rawPJRequest)
	return rawPJRequest
}

func convertRawResponseToHumanResponse(rawResponse RawPJResponse,
	requestParameter string) (PJResponse, error) {
	fmt.Print("rawResponse:")
	fmt.Println(rawResponse)
	response := PJResponse{Class: rawResponse.Class,
		Command:  RawToHumanCommands[rawResponse.Command],
		Response: make([]string, len(rawResponse.Response))}
	switch response.Command {
	case "power":
		if requestParameter == "query" {
			response.Response[0] = PowerQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response[0] = PowerResponses[rawResponse.Response[0]]
		}
	case "input-list":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = InputListQueryResponses[rawResponse.Response[0]]
		}
		response.Response = interpretInputListInputs(rawResponse.Response)
	case "input":
		response.Response[0] = InputResponses[rawResponse.Response[0]]
	case "av-mute":
		if requestParameter == "query" {
			response.Response[0] = AVMuteQueryResponses[rawResponse.Response[0]]
		} else { //command
			response.Response[0] = AVMuteResponses[rawResponse.Response[0]]
		}
	case "error-status":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = AVMuteQueryResponses[rawResponse.Response[0]]
		} else {
			humanErrorResponses := interpretErrorStatusResponse(rawResponse.Response)
			fmt.Println(humanErrorResponses)
			response.Response = humanErrorResponses
		}

	case "lamp":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = LampQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response = interpretLampQueryResponse(rawResponse.Response)
		}
	case "name":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = NameQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response[0] = rawResponse.Response[0]
		}
	case "manufacturer":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = ManufacturerQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response[0] = rawResponse.Response[0]
		}
	case "model":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = ModelQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response[0] = rawResponse.Response[0]
		}
	case "version":
		if (rawResponse.Response[0] == "ERR3") || (rawResponse.Response[0] == "ERR4") {
			response.Response[0] = VersionQueryResponses[rawResponse.Response[0]]
		} else {
			response.Response = rawResponse.Response
		}
	}
	return response, nil
}

func odd(number int) bool {
	return number%2 != 0
}

func interpretLampQueryResponse(rawLampResponse []string) []string {
	sets := len(rawLampResponse) / 2
	humanLampResponses := make([]string, sets)
	for index := range humanLampResponses {
		humanLampResponses[index] = "Lamp: " + strconv.Itoa(index+1) +
			", hours: " + rawLampResponse[index*2] + ", state: " +
			" " + LampStateResponses[rawLampResponse[(index*2)+1]]
	}

	return humanLampResponses
}

func interpretErrorStatusResponse(rawResponse []string) []string {
	fmt.Println(rawResponse)
	raw := rawResponse[0]
	rawValues := make([]string, 6)
	for index := range rawValues {
		rawValues[index] = raw[index : index+1]
	}
	fmt.Println(rawValues)

	humanCodes := make([]string, 6)
	for index := range humanCodes {
		switch rawValues[index] {
		case "0":
			humanCodes[index] = "OK"
		case "1":
			humanCodes[index] = "Warning"
		case "2":
			humanCodes[index] = "Error"
		default:

		}
	}
	humanResponses := []string{
		"fan: " + humanCodes[0],
		"lamp: " + humanCodes[1],
		"temperature: " + humanCodes[2],
		"cover open: " + humanCodes[3],
		"filter: " + humanCodes[4],
		"other: " + humanCodes[5],
	}

	return humanResponses
}

func interpretInputListInputs(rawResponses []string) []string {
	humanResponses := make([]string, len(rawResponses))
	for index, element := range rawResponses {
		humanResponses[index] = RawToHumanInputs[element]
	}
	return humanResponses
}

func validateHumanRequest(request PJRequest) error {
	//class 1?
	if request.Class != "1" {
		return errors.New("only PJLink class 1 supported")
	}

	//valid PJLink class 1 command?
	if HumanToRawCommands[request.Command] == "" {
		return errors.New("'" + request.Command + "' is not a valid PJLink command.")
	}

	//valid parameter for given command?
	validateCommandParameterError := validateCommandParameter(request)
	if validateCommandParameterError != nil {
		return validateCommandParameterError
	}
	//all is well, so return nil error
	return nil
}

func validateCommandParameter(request PJRequest) error {
	var badParameter bool = false
	switch request.Command {
	case "power":
		if PowerRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "input-list":
		if InputListRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "input":
		if InputRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "av-mute":
		if AVMuteRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "error-status":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "lamp":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "name":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "manufacturer":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "model":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	case "version":
		if ErrorStatusRequests[request.Parameter] == "" {
			badParameter = true
		}
	}

	if badParameter {
		return errors.New("'" + request.Parameter +
			"' is not a valid parameter for PJLink command '" +
			request.Command + "'.")
	} else {
		return nil
	}
}
